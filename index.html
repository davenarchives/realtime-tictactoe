<!doctype html>
<html>
<head>
  <meta charset='utf-8' />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Realtime Tic-Tac-Toe</title>
  <link rel="icon" type="icon" href="assets/tic-tac-toe.png">
  <link rel='preconnect' href='https://fonts.googleapis.com'>
  <link rel='preconnect' href='https://fonts.gstatic.com' crossorigin>
  <link href='https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Varela+Round&display=swap' rel='stylesheet'>
  <link rel='stylesheet' href='style.css' />
</head>
<body>
  <main class='card'>
    <header class='brand'>
      <h1>
        <span class='logo-word logo-word--tic'>Tic</span>
        <span class='logo-divider'>-</span>
        <span class='logo-word logo-word--tac'>Tac</span>
        <span class='logo-divider'>-</span>
        <span class='logo-word logo-word--toe'>Toe</span>
      </h1>
      <p id='status' class='status-line'><span id='status-text'></span></p>
    </header>

    <section id='lobby' class='lobby'>
      <form id='join-form' autocomplete='off' class='login'>
        <label for='player-name'>Enter username:</label>
        <input id='player-name' name='player-name' type='text' maxlength='24' placeholder='Player name' autofocus />
        <button id='join-button' type='submit'>Search for a player</button>
      </form>
      <p id='lobby-status' class='lobby-status'>Enter your name to join a match.</p>
    </section>

    <section id='mode-selection' class='mode-selection hidden'>
      <h2 class='mode-title'>Choose Your Battle Mode</h2>
      <p class='mode-subtitle'>Vote for the game mode</p>
      
      <div class='mode-grid'>
        <button class='mode-card' data-mode='BLITZ'>
          <div class='mode-name'>BLITZ</div>
          <div class='mode-desc'>1 Round Match</div>
          <div class='mode-icon'>‚ö°</div>
        </button>
        
        <button class='mode-card' data-mode='SKIRMISH'>
          <div class='mode-name'>SKIRMISH</div>
          <div class='mode-desc'>3 Rounds Match</div>
          <div class='mode-icon'>‚öîÔ∏è</div>
        </button>
        
        <button class='mode-card' data-mode='DEATHMATCH'>
          <div class='mode-name'>DEATHMATCH</div>
          <div class='mode-desc'>5 Rounds Match</div>
          <div class='mode-icon'>üíÄ</div>
        </button>
        
        <button class='mode-card' data-mode='RANDOM'>
          <div class='mode-name'>RANDOM</div>
          <div class='mode-desc'>Surprise Me!</div>
          <div class='mode-icon'>üé≤</div>
        </button>
      </div>
      
      <div id='vote-status' class='vote-status'></div>
    </section>

    <section id='game' class='game hidden' aria-live='polite'>
      <div id='round-indicator' class='round-indicator hidden'></div>
      
      <div class='turnline'>
        <span id='assignment'></span>
        <strong id='turn-indicator'></strong>
      </div>

      <div id='board' class='board' role='grid' aria-label='Tic Tac Toe board'></div>

      <footer class='scoreboard' aria-label='Match scoreboard'>
        <div class='score' id='score-x'>
          <span class='label'><span class='tag-x'>Player X</span></span>
          <span class='value'>0</span>
        </div>
        <div class='score' id='score-tie'>
          <span class='label'>TIE</span>
          <span class='value'>0</span>
        </div>
        <div class='score' id='score-o'>
          <span class='label'><span class='tag-o'>Player O</span></span>
          <span class='value'>0</span>
        </div>
      </footer>
    </section>
  </main>

  <div id='series-modal' class='modal hidden' role='dialog' aria-modal='true' aria-labelledby='series-title'>
    <div class='modal-content'>
      <h2 id='series-title'>Series Winner!</h2>
      <p id='series-message'></p>
      <p id='series-status' class='series-status'></p>
    </div>
  </div>

  <script src='/socket.io/socket.io.js'></script>
  <script>
    const socket = io();

    const statusTextEl = document.getElementById('status-text');
    const boardEl = document.getElementById('board');
    const lobbyEl = document.getElementById('lobby');
    const joinForm = document.getElementById('join-form');
    const nameInput = document.getElementById('player-name');
    const joinButton = document.getElementById('join-button');
    const lobbyStatusEl = document.getElementById('lobby-status');
    const gameEl = document.getElementById('game');
    const assignmentEl = document.getElementById('assignment');
    const turnIndicatorEl = document.getElementById('turn-indicator');
    const scoreXLabel = document.querySelector('#score-x .label');
    const scoreTieLabel = document.querySelector('#score-tie .label');
    const scoreOLabel = document.querySelector('#score-o .label');
    const scoreXEl = document.querySelector('#score-x .value');
    const scoreTieEl = document.querySelector('#score-tie .value');
    const scoreOEl = document.querySelector('#score-o .value');
    const seriesModalEl = document.getElementById('series-modal');
    const seriesMessageEl = document.getElementById('series-message');
    const seriesStatusEl = document.getElementById('series-status');
    const modeSelectionEl = document.getElementById('mode-selection');
    const modeCards = document.querySelectorAll('.mode-card');
    const voteStatusEl = document.getElementById('vote-status');
    const roundIndicatorEl = document.getElementById('round-indicator');

    const SEARCH_TIMEOUT_MS = 10000;
    const AUTO_RESET_DELAY_MS = 1500;
    const SERIES_EXIT_DELAY_MS = 3000;

    function emptyState() {
      return { board: Array(9).fill(null), turn: 'X', result: null };
    }

    let me = null;
    let myName = '';
    let state = emptyState();
    let playerNames = { X: null, O: null };
    let searching = false;
    let scoreboard = { X: 0, O: 0, tie: 0 };
    let modeVotes = { X: null, O: null };
    let selectedMode = null;
    let currentRound = 0;
    let totalRounds = 1;
    let seriesScore = { X: 0, O: 0 };
    let myVote = null;
    let autoResetTimer = null;
    let seriesExitTimer = null;
    let searchCountdownTimer = null;
    let searchTimeoutTimer = null;
    let searchSecondsRemaining = 0;
    let searchStatusOverride = '';
    let retainNameNextReset = false;

    statusTextEl.textContent = 'Enter your name to join a match.';

    function sanitizePlayers(players = {}) {
      return {
        X: players.X && players.X.name ? players.X.name : null,
        O: players.O && players.O.name ? players.O.name : null
      };
    }

    function playerLabel(symbol) {
      if (symbol === 'X') return playerNames.X || 'Player X';
      if (symbol === 'O') return playerNames.O || 'Player O';
      return '';
    }

    function opponentSymbol(symbol) {
      if (symbol === 'X') return 'O';
      if (symbol === 'O') return 'X';
      return null;
    }

    function clearAutoResetTimer() {
      if (autoResetTimer) {
        clearTimeout(autoResetTimer);
        autoResetTimer = null;
      }
    }

    function scheduleAutoReset() {
      clearAutoResetTimer();
      autoResetTimer = setTimeout(() => {
        socket.emit('reset');
        autoResetTimer = null;
      }, AUTO_RESET_DELAY_MS);
    }

    function clearSeriesExitTimer() {
      if (seriesExitTimer) {
        clearTimeout(seriesExitTimer);
        seriesExitTimer = null;
      }
    }

    function setSeriesStatus(text = '') {
      if (seriesStatusEl) {
        seriesStatusEl.textContent = text;
      }
    }

    function scheduleSeriesExit() {
      clearSeriesExitTimer();
      setSeriesStatus('Returning to matchmaking...');
      seriesExitTimer = setTimeout(() => {
        seriesExitTimer = null;
        socket.emit('series_exit');
      }, SERIES_EXIT_DELAY_MS);
    }

    function hideSeriesModal() {
      if (seriesModalEl) {
        seriesModalEl.classList.add('hidden');
      }
      setSeriesStatus('');
    }

    function formatSearchCountdown(seconds) {
      return `Searching for an opponent (${seconds}s)`;
    }

    function setSearchStatus(message) {
      searchStatusOverride = message || '';
      updateLobbyStatus();
    }

    function clearSearchTimers() {
      if (searchCountdownTimer) {
        clearInterval(searchCountdownTimer);
        searchCountdownTimer = null;
      }
      if (searchTimeoutTimer) {
        clearTimeout(searchTimeoutTimer);
        searchTimeoutTimer = null;
      }
      searchSecondsRemaining = 0;
    }

    function startOpponentSearch() {
      clearSearchTimers();
      searchSecondsRemaining = Math.floor(SEARCH_TIMEOUT_MS / 1000);
      setSearchStatus(formatSearchCountdown(searchSecondsRemaining));
      searchCountdownTimer = setInterval(() => {
        searchSecondsRemaining -= 1;
        if (searchSecondsRemaining > 0) {
          setSearchStatus(formatSearchCountdown(searchSecondsRemaining));
        } else {
          clearInterval(searchCountdownTimer);
          searchCountdownTimer = null;
        }
      }, 1000);
      searchTimeoutTimer = setTimeout(() => {
        clearSearchTimers();
        searching = false;
        joinButton.disabled = false;
        nameInput.disabled = false;
        setSearchStatus('No opponent found');
        retainNameNextReset = true;
        socket.emit('series_exit');
      }, SEARCH_TIMEOUT_MS);
    }

    function stopOpponentSearch({ clearMessage = false } = {}) {
      clearSearchTimers();
      if (clearMessage) {
        setSearchStatus('');
      }
    }

    function showModeSelection() {
      lobbyEl.classList.add('hidden');
      gameEl.classList.add('hidden');
      modeSelectionEl.classList.remove('hidden');
      myVote = null;
      updateVoteStatus();
    }

    function hideModeSelection() {
      modeSelectionEl.classList.add('hidden');
    }

    function updateVoteStatus() {
      if (!voteStatusEl) return;
      
      const xName = playerNames.X || 'Player X';
      const oName = playerNames.O || 'Player O';
      const xVote = modeVotes.X;
      const oVote = modeVotes.O;
      
      let status = '';
      
      if (xVote && oVote) {
        status = `${xName} voted ${xVote} ‚Ä¢ ${oName} voted ${oVote}`;
      } else if (xVote) {
        status = `${xName} voted ${xVote} ‚Ä¢ Waiting for ${oName}...`;
      } else if (oVote) {
        status = `${oName} voted ${oVote} ‚Ä¢ Waiting for ${xName}...`;
      } else {
        status = 'Waiting for votes...';
      }
      
      voteStatusEl.textContent = status;
    }

    function updateRoundIndicator() {
      if (!roundIndicatorEl) return;
      
      if (totalRounds > 1 && currentRound > 0) {
        roundIndicatorEl.textContent = `Round ${currentRound} of ${totalRounds}`;
        roundIndicatorEl.classList.remove('hidden');
      } else {
        roundIndicatorEl.classList.add('hidden');
      }
    }

    function updateScoreboardLabels() {
      const xName = playerLabel('X');
      const oName = playerLabel('O');
      scoreXLabel.innerHTML = `${xName}<span class="tag-x">(X)</span>`;
      scoreTieLabel.textContent = 'TIE';
      scoreOLabel.innerHTML = `${oName}<span class="tag-o">(O)</span>`;
    }

    function updateScoreboardDisplay() {
      if (totalRounds > 1) {
        scoreXEl.textContent = seriesScore.X;
        scoreOEl.textContent = seriesScore.O;
        scoreTieEl.textContent = 0;
      } else {
        scoreXEl.textContent = scoreboard.X;
        scoreTieEl.textContent = scoreboard.tie;
        scoreOEl.textContent = scoreboard.O;
      }
    }

    function resetScoreboard() {
      scoreboard = { X: 0, O: 0, tie: 0 };
      seriesScore = { X: 0, O: 0 };
      updateScoreboardDisplay();
      clearSeriesExitTimer();
      hideSeriesModal();
    }

    function updateLobbyStatus(message) {
      const ready = Boolean(playerNames.X && playerNames.O);
      let text = message || '';

      if (!text) {
        if (searchStatusOverride) {
          text = searchStatusOverride;
        } else if (me) {
          if (ready) {
            const opponent = me === 'X' ? playerNames.O : playerNames.X;
            text = opponent ? `Matched with ${opponent}.` : 'Waiting for another player to join...';
          } else if (searching) {
            text = 'Searching for an opponent.';
          } else {
            text = 'Enter your name to join a match.';
          }
        } else if (searching) {
          text = 'Searching for an opponent.';
        } else if (playerNames.X || playerNames.O) {
          const xName = playerNames.X;
          const oName = playerNames.O;
          if (xName && oName) {
            text = `Watching ${xName} and ${oName}'s match.`;
          } else {
            const waiting = xName || oName || 'A player';
            text = `${waiting} is waiting for an opponent.`;
          }
        } else {
          text = 'Enter your name to join a match.';
        }
      }

      lobbyStatusEl.textContent = text;
      if (gameEl.classList.contains('hidden')) {
        statusTextEl.textContent = text;
      }
    }

    function updateGameVisibility() {
      const ready = Boolean(playerNames.X && playerNames.O);
      const playing = ready && (me === 'X' || me === 'O');
      const spectating = ready && !me && !searching;
      const showGame = (playing || spectating) && selectedMode;

      lobbyEl.classList.toggle('matched', ready);
      gameEl.classList.toggle('hidden', !showGame);
      boardEl.style.pointerEvents = showGame && !state.result ? 'auto' : 'none';

      if (showGame) {
        statusTextEl.textContent = '';
      }
      
      updateRoundIndicator();
    }

    function renderAssignment() {
      if (!me || !playerNames.X || !playerNames.O) {
        assignmentEl.textContent = '';
        return;
      }
      const colorClass = me === 'X' ? 'tag-x' : 'tag-o';
      assignmentEl.innerHTML = `You are playing as <span class="${colorClass}">${me}</span>`;
    }

    function renderTurnIndicator() {
      if (state.result) {
        if (state.result === 'Draw') {
          turnIndicatorEl.textContent = "It's a draw";
        } else {
          const cls = state.result === 'X' ? 'tag-x' : 'tag-o';
          const winnerName = playerLabel(state.result);
          turnIndicatorEl.innerHTML = `<span class="${cls}">${winnerName}</span> wins!`;
        }
        return;
      }
      const cls = state.turn === 'X' ? 'tag-x' : 'tag-o';
      const currentPlayerName = playerLabel(state.turn);
      turnIndicatorEl.innerHTML = `<span class="${cls}">${currentPlayerName}</span>'s turn`;
    }

    function drawBoard() {
      boardEl.innerHTML = '';
      state.board.forEach((value, index) => {
        const cell = document.createElement('button');
        cell.className = 'cell';

        if (value) {
          cell.textContent = value.toLowerCase();
          cell.classList.add(value === 'X' ? 'is-x' : 'is-o');
        }

        const canPlay = !value && me && state.turn === me && !state.result;
        console.log(`[v0] Cell ${index}: value=${value}, me=${me}, turn=${state.turn}, result=${state.result}, canPlay=${canPlay}`);
        cell.disabled = !canPlay;
        if (!canPlay && !value) cell.classList.add('muted');

        cell.addEventListener('click', () => socket.emit('move', index));
        boardEl.appendChild(cell);
      });
    }

    function draw() {
      renderAssignment();
      renderTurnIndicator();
      drawBoard();
      updateGameVisibility();
      updateLobbyStatus();
      updateScoreboardLabels();
      updateScoreboardDisplay();
    }

    function announceSeriesWinner(symbol) {
      if (!seriesModalEl || !seriesMessageEl) {
        return;
      }
      clearAutoResetTimer();
      clearSeriesExitTimer();

      const opponent = opponentSymbol(symbol);
      const winnerName = playerLabel(symbol);
      const opponentName = playerLabel(opponent);
      const winnerScore = scoreboard[symbol];
      const opponentScore = opponent ? scoreboard[opponent] : 0;

      let summary = `${winnerName} wins the series!`;
      if (opponentName) {
        summary = `${winnerName} wins the series ${winnerScore}-${opponentScore}!`;
      }

      seriesMessageEl.textContent = summary;
      seriesModalEl.classList.remove('hidden');
      scheduleSeriesExit();
    }

    function handleResult(result) {
      if (result === 'X' || result === 'O') {
        scoreboard[result] += 1;
        updateScoreboardDisplay();
        if (scoreboard[result] >= 5) {
          announceSeriesWinner(result);
          return;
        }
        scheduleAutoReset();
      } else if (result === 'Draw') {
        scoreboard.tie += 1;
        updateScoreboardDisplay();
        scheduleAutoReset();
      } else {
        updateScoreboardDisplay();
      }
    }

    modeCards.forEach(card => {
      card.addEventListener('click', () => {
        if (myVote || !me) return;
        
        const mode = card.dataset.mode;
        myVote = mode;
        
        modeCards.forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        
        socket.emit('vote_mode', mode);
      });
    });

    joinForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const name = nameInput.value.trim();
      if (!name) {
        updateLobbyStatus('Please enter your name.');
        nameInput.focus();
        return;
      }
      myName = name;
      retainNameNextReset = false;
      stopOpponentSearch({ clearMessage: true });
      searching = true;
      joinButton.disabled = true;
      nameInput.disabled = true;
      startOpponentSearch();
      socket.emit('join', { name });
      updateLobbyStatus();
    });

    socket.on('init', (payload = {}) => {
      statusTextEl.textContent = '';
      state = {
        board: Array.isArray(payload.board) ? payload.board.slice() : emptyState().board,
        turn: payload.turn || 'X',
        result: payload.result || null
      };
      me = payload.yourSymbol;
      playerNames = sanitizePlayers(payload.players);
      modeVotes = payload.modeVotes || { X: null, O: null };
      selectedMode = payload.selectedMode || null;
      currentRound = payload.currentRound || 0;
      totalRounds = payload.totalRounds || 1;
      seriesScore = payload.seriesScore || { X: 0, O: 0 };
      resetScoreboard();
      searching = false;
      stopOpponentSearch({ clearMessage: true });
      draw();
    });

    socket.on('joined', (payload = {}) => {
      state = {
        board: Array.isArray(payload.board) ? payload.board.slice() : emptyState().board,
        turn: payload.turn || 'X',
        result: payload.result || null
      };
      me = payload.yourSymbol;
      playerNames = sanitizePlayers(payload.players);
      myName = payload.name || myName;
      modeVotes = payload.modeVotes || { X: null, O: null };
      selectedMode = payload.selectedMode || null;
      currentRound = payload.currentRound || 0;
      totalRounds = payload.totalRounds || 1;
      seriesScore = payload.seriesScore || { X: 0, O: 0 };
      searching = false;
      const ready = Boolean(playerNames.X && playerNames.O);
      if (ready) {
        stopOpponentSearch({ clearMessage: true });
      } else if (!searchCountdownTimer && !searchTimeoutTimer) {
        startOpponentSearch();
      }
      joinButton.disabled = false;
      nameInput.disabled = false;
      resetScoreboard();
      draw();
    });

    socket.on('waiting', ({ message } = {}) => {
      stopOpponentSearch({ clearMessage: true });
      searching = true;
      joinButton.disabled = false;
      nameInput.disabled = false;
      statusTextEl.textContent = 'Waiting for a seat...';
      updateLobbyStatus(message || 'Game already has two players. Waiting for a seat...');
    });

    socket.on('join_error', ({ message } = {}) => {
      stopOpponentSearch({ clearMessage: true });
      searching = false;
      joinButton.disabled = false;
      nameInput.disabled = false;
      statusTextEl.textContent = 'Unable to join.';
      updateLobbyStatus(message || 'Unable to join the match.');
    });

    socket.on('players', (players = {}) => {
      playerNames = sanitizePlayers(players);
      if (playerNames.X && playerNames.O) {
        stopOpponentSearch({ clearMessage: true });
      }
      draw();
    });

    socket.on('mode_selection_start', () => {
      modeVotes = { X: null, O: null };
      selectedMode = null;
      myVote = null;
      
      modeCards.forEach(c => c.classList.remove('selected'));
      
      if (me === 'X' || me === 'O') {
        showModeSelection();
      }
    });

    socket.on('mode_votes', (votes) => {
      modeVotes = votes;
      updateVoteStatus();
    });

    socket.on('mode_selected', (payload) => {
      selectedMode = payload.mode;
      totalRounds = payload.totalRounds;
      currentRound = payload.currentRound;
      
      hideModeSelection();
      lobbyEl.classList.remove('hidden');
      
      const modeName = payload.mode;
      const modeDesc = totalRounds === 1 ? '1 round' : `${totalRounds} rounds`;
      updateLobbyStatus(`Mode selected: ${modeName} (${modeDesc})`);
      
      setTimeout(() => {
        draw();
      }, 1000);
    });

    socket.on('symbol_update', (payload) => {
      console.log('[v0] Received symbol_update:', payload.yourSymbol, 'previous:', me);
      me = payload.yourSymbol;
      console.log('[v0] Updated me to:', me, 'current turn:', state.turn);
      draw();
    });

    socket.on('next_round', (payload) => {
      currentRound = payload.currentRound;
      totalRounds = payload.totalRounds;
      seriesScore = payload.seriesScore;
      playerNames = sanitizePlayers(payload.players);
      
      if (payload.symbolMap && payload.symbolMap[socket.id]) {
        me = payload.symbolMap[socket.id];
        console.log('[v0] Next round: Updated symbol to', me, 'for round', currentRound);
      }
      
      updateRoundIndicator();
      updateScoreboardLabels();
      updateScoreboardDisplay();
      draw();
    });

    socket.on('series_complete', (payload) => {
      const winner = payload.winner;
      const score = payload.score;
      
      if (!seriesModalEl || !seriesMessageEl) return;
      
      clearAutoResetTimer();
      clearSeriesExitTimer();
      
      let summary = '';
      if (winner) {
        const winnerName = playerLabel(winner);
        const loser = winner === 'X' ? 'O' : 'X';
        summary = `${winnerName} wins the series ${score[winner]}-${score[loser]}!`;
      } else {
        summary = `Series tied ${score.X}-${score.O}!`;
      }
      
      seriesMessageEl.textContent = summary;
      seriesModalEl.classList.remove('hidden');
      scheduleSeriesExit();
    });

    socket.on('series_reset', () => {
      clearAutoResetTimer();
      clearSeriesExitTimer();
      resetScoreboard();
      state = emptyState();
      playerNames = { X: null, O: null };
      me = null;
      modeVotes = { X: null, O: null };
      selectedMode = null;
      currentRound = 0;
      totalRounds = 1;
      seriesScore = { X: 0, O: 0 };
      myVote = null;
      hideModeSelection();
      const keepName = retainNameNextReset;
      retainNameNextReset = false;
      if (!keepName) {
        myName = '';
      }
      searching = false;
      stopOpponentSearch({ clearMessage: !keepName });
      joinButton.disabled = false;
      nameInput.disabled = false;
      nameInput.value = keepName ? myName : '';
      lobbyEl.classList.remove('matched');
      if (keepName) {
        updateLobbyStatus();
      } else {
        statusTextEl.textContent = 'Enter your name to join a match.';
        updateLobbyStatus('Enter your name to join a match.');
      }
      draw();
    });

    socket.on('state', (newState = {}) => {
      const previousResult = state.result;
      if (Array.isArray(newState.board)) state.board = newState.board.slice();
      if (typeof newState.turn === 'string' || newState.turn === null) state.turn = newState.turn || 'X';
      state.result = newState.result || null;
      if (newState.players) playerNames = sanitizePlayers(newState.players);
      if (typeof newState.currentRound === 'number') currentRound = newState.currentRound;
      if (typeof newState.totalRounds === 'number') totalRounds = newState.totalRounds;
      if (newState.seriesScore) seriesScore = newState.seriesScore;

      if (!state.result) {
        clearAutoResetTimer();
        if (previousResult) {
          clearSeriesExitTimer();
          hideSeriesModal();
        }
      }

      if (!previousResult && state.result) {
        handleResult(state.result);
      }

      draw();
    });

    socket.on('disconnect', () => {
      stopOpponentSearch({ clearMessage: true });
      statusTextEl.textContent = 'Disconnected. Attempting to reconnect...';
      me = null;
      searching = false;
      joinButton.disabled = false;
      nameInput.disabled = false;
      lobbyEl.classList.remove('matched');
      hideModeSelection();
      updateLobbyStatus();
    });

    socket.io.on('reconnect', () => {
      stopOpponentSearch({ clearMessage: true });
      if (myName) {
        statusTextEl.textContent = 'Reconnecting...';
        joinButton.disabled = true;
        nameInput.disabled = true;
        socket.emit('join', { name: myName });
      } else {
        statusTextEl.textContent = 'Enter your name to join a match.';
      }
    });
  </script>
</body>
</html>
